<!DOCTYPE HTML>
<html>
<head>
<meta charset="utf-8">
<title>SignalsLite Tests</title>
<script src="qunit/qunit.js"></script>
<script src="../src/SignalLite.js"></script>
<link href="qunit/qunit.css" rel="stylesheet" type="text/css">
</head>

<body>
<h1 id="qunit-header">SignalsLite Tests</h1>
<h2 id="qunit-banner"></h2>
<h2 id="qunit-userAgent"></h2>
<ol id="qunit-tests"></ol>
<script>
(function() { "use strict";

var tested = new SignalLite();

module("SignalsLite");

test( "Basic Requirements", function() {
	expect(4);
	ok( Function.prototype.apply, "Function.apply()" );
	ok( (function named() {
			ok( named, "Named inline function" );
			return true;
		})(),
		"Named inline function 2"
	);
	var T;
	(function() {
		T=function T(){}
		T.prototype.test = 1;
	})();
	ok((new T).test, "Exported T should have prototype methods");
});

test( "after setup, with 0 listeners", function()
{
	expect(2);
	var signaled = new SignalLite();
	
	equal(
		signaled.first, signaled.last,
		"after init, SignalLite.first and SignalLite.last should be equal."
	);
	
	strictEqual(
		signaled.first, signaled.last,
		"after init, SignalLite.first and SignalLite.last should be strictly equal."
	);
});

test("IE7/IE8 - object incorrectness", function()
{
	var signaled = new SignalLite();
	var listener = function() {};
	
	ok( signaled, "signaled exists" );
	ok( signaled.has, "signaled.has exists");
});

test("add, remove, has listener", function()
{
	var signaled = new SignalLite();
	var listener = function() {};
	var listener2 = function() {};
	
	ok( !signaled.has(listener),
		"signaled shouldn't has listener" );
	strictEqual( signaled.getLength(), 0,
		"signaled should has 0 listeners" );
	
	signaled.add( listener );
	strictEqual( signaled.getLength(), 1,
		"signaled should has 1 listener" );
	ok( signaled.has(listener),
		"signaled should has listener" );
	
	signaled.add( listener );
	strictEqual( signaled.getLength(), 1,
		"signaled should have 1 listener after adding a previously added listener again");
	
	signaled.add( listener2 );
	ok( signaled.has( listener2 ),
		"signaled should has listener2" );
	strictEqual( signaled.getLength(), 2,
		"signaled should have 2 listeners after adding a second listener");
	signaled.remove(listener2);
	strictEqual( signaled.getLength(), 1,
		"signaled should have 1 listener after removing second listener");
	
	signaled.remove(listener);
	ok( !signaled.has(listener),
		"signaled shouldn't have listener" );
	strictEqual( signaled.getLength(), 0,
		"signaled should have 0 listeners");
	
	signaled.remove(listener);
});

test("normal dispatching", function()
{
	var signaled = new SignalLite();
	
	var dispatchedCount = 0;
	var listener = function() {
		dispatchedCount++;
	};
	
	signaled.add( listener );
	
	equal( dispatchedCount, 0, "dispatchedCount should be 0 before dispatch" );
	
	signaled.dispatch();
	equal( dispatchedCount, 1, "dispatchedCount should be 1 after one dispatch" );
	
	signaled.dispatch();
	equal( dispatchedCount, 2, "dispatchedCount should be 2 after two dispatches" );
	
	signaled.remove( listener );
});
test("once dispatching", function()
{
	var signaled = new SignalLite();
	
	var dispatchedCount = 0;
	signaled.once( function() {
		dispatchedCount++;
	} );
	
	strictEqual( dispatchedCount, 0, "dispatchedCount should be 0 before once dispatch" );
	strictEqual( signaled.getLength(), 1, "signaled should has 1 listener" );
	strictEqual( dispatchedCount, 0, "dispatchedCount should be 0 before dispatch" );
	
	signaled.dispatch();
	strictEqual( dispatchedCount, 1, "dispatchedCount should be 1 after one dispatch" );
	strictEqual( signaled.getLength(), 0, "signaled should has 0 listeners" );
	
	signaled.dispatch();
	strictEqual( dispatchedCount, 1, "dispatchedCount should be 1 after two dispatches" );
});

test("dispatching with arguments", function() {
	
	var signaled = new SignalLite();
	
	function listener( string, number, array ) {
		strictEqual( string, "", "argument should be a string");
		strictEqual( number, 0, "argument should be a number");
		deepEqual( array, [0,1,"3"], "argument should be an array[0,1,\"3\"]");
	}
	
	signaled.add( listener );
	signaled.dispatch( "", 0, [0,1,"3"] );
	
} );
test("dispatching with thisArg", function() {
	
	var target = {};
	var target2 = {};
	var signaled = new SignalLite( target );
	
	signaled.add( function listener() {
		equal( target, this, "this should equal target" );
		signaled.remove( listener );
	} );
	signaled.dispatch();
	
	signaled.add( function listener() {
		notEqual( target, this, "this should not equal target");
		equal( target2, this, "this should equal target2");
		signaled.remove( listener );
	}, target2 );
	signaled.dispatch();
	
	signaled.once( function listener() {
		notEqual( target, this, "this should not equal target");
		equal( target2, this, "this should equal target2");
	}, target2 );
	signaled.dispatch();
} );

test("errors during dispatching", function() {
	
	var signaled = new SignalLite();
	
	var signaledCount = 0;
	
	// http://dean.edwards.name/weblog/2009/03/callbacks-vs-events/
	signaled.add( function() {
		signaledCount++;
		DOES_NOT_EXIST++; // this will throw an error
	} );
	
	signaled.add( function() {
		signaledCount++;
	} );
	
	signaled.dispatch();
	
	equal( signaledCount, 2, "Both listeners should have incremented signaledCount." );
} );

test( "dispatch within a dispatch", function() {
	
	expect( 9 );
	
	var signaled1 = new SignalLite();
	var signaled2 = new SignalLite();
	
	var count1 = 0;
	var count2 = 0;
	
	signaled1.add( function() {
		count1++;
		equal( count1, 1, "count1 should be 1 - first iterator" );
	} );
	signaled1.add( function() {
		equal( count1, 1, "count1 should be 1 before signaled2 is dispatched" );
		signaled2.dispatch();
		equal( count1, 1, "count1 should still be 1 after signaled2 is dispatched" );
	} );
	signaled1.add( function() {
		count1++;
		equal( count1, 2, "count1 should be 2 - second iterator" );
	} );
	signaled1.add( function() {
		count1++;
		equal( count1, 3, "count1 should be 3 - third iterator" );
	} );
	
	signaled2.add( function() {
		count2++;
		equal( count2, 1, "count2 should be  - first iterator2" );
	} );
	signaled2.add( function() {
		count2++;
		equal( count2, 2, "count2 should be 2 - second iterator2" );
	} );
	signaled2.add( function() {
		count2++;
		equal( count2, 3, "count2 should be 3 - third iterator2" );
	} );
	
	signaled1.dispatch();
	
	equal( count1, count2, "Each signaled should have dispatched to the same number of listeners" );
} );

test( "namespaces", function() {
	
	var signaled = new SignalLite();
	
	var count = 0;
	
	signaled.ns( "namespace1" ).add( function() {
		count++;
	} );
	signaled.ns( "namespace1" ).add( function() {
		count++;
	} );
	signaled.add( function() {
		count++;
	} );
	
	//signaled.dispatch( "namespace1" );
	//equal( count, 2, "namespace dispatched should have only hit two listeners" );
	
	count = 0;
	signaled.dispatch();
	equal( count, 3, "unnamespaced dispatch should have hit all 3 listeners" );
	
	signaled.ns( "namespace1" ).remove();
	count = 0;
	signaled.dispatch();
	equal( count, 1, "should only be one listener left" );
	
	signaled.ns( "namespace1" ).once( function() {} );
	signaled.ns( "namespace1" ).add( function() {} );
	equal( signaled.getLength(), 3, "Should be three listeners" );
	signaled.ns( "namespace1" ).remove();
	equal( signaled.getLength(), 1, "Should be only one left, after clearing the namespace" );
	
} );

})();
</script>
</body>
</html>
